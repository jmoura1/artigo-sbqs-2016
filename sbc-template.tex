\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}

%\usepackage[brazil]{babel}   
\usepackage[latin1]{inputenc}  

     
\sloppy

\title{Título\\ Papers and Abstracts}

\author{Jéssica Lasch de Moura\inst{1}, Andrea Schwertner Charão\inst{1}}


\address{XX -- Universidade Federal de Santa Maria
  (UFSM)\\
  Santa Maria -- RS -- Brazil
\nextinstitute
  Department of Computer Science -- University of Durham\\
  Durham, U.K.
  \email{\{jmoura,andrea\}@inf.ufsm.br}
}
\begin{document} 

\maketitle

\begin{abstract}
  This meta-paper describes the style to be used in articles and short papers
  for SBC conferences. For papers in English, you should add just an abstract
  while for the papers in Portuguese, we also ask for an abstract in
  Portuguese (``resumo''). In both cases, abstracts should not have more than
  10 lines and must be in the first page of the paper.
\end{abstract}
     
\begin{resumo} 
  Este meta-artigo descreve o estilo a ser usado na confecção de artigos e
  resumos de artigos para publicação nos anais das conferências organizadas
  pela SBC. É solicitada a escrita de resumo e abstract apenas para os artigos
  escritos em português. Artigos em inglês deverão apresentar apenas abstract.
  Nos dois casos, o autor deve tomar cuidado para que o resumo (e o abstract)
  não ultrapassem 10 linhas cada, sendo que ambos devem estar na primeira
  página do artigo.
\end{resumo}


\section{Introdução}

-Importância dos testes
	-Trabalho anterior: teste de carga + teste funcional;
	-Teste funcional com selenium e cucumber mais promissor, mas pode ser trabalhoso;
	-Alternativa pra auxiliar na criação dos testes: analisar o diagrama no formato BPMN e criar artefatos;
	-Objetivo: melhorar e facilitar o teste funcional;

\section{BPM e Teste}
-Teste é pouco abordado
-Teste é importante
-Teste funcional ajuda a aumentar a qualidade do software;
-Trabalhos relacionados;


\section{BPMN}
-O que é;
-Alguns exemplos;
-A maioria da ferramentas disponibilizam a exportação dos processos para esse formato e segue o mesmo padrão;
-Alguns exemplos de notação;
-Principais elementos;
explicar bem o sequenceflow, atributos…
start event e end event

\section{Teste Funcional}
-O que é...

\subsection{Teste com selenium}
-funcionamento, elementos  necessários  pro  teste
\subsection{Teste com cucumber}
-funcionamento, elementos  necessários  pro  teste

\section{BPMN Parser}
-Linguagem, ferramenta,exemplos de diagramas foram obtidos em...
-O que o parser  faz (resumo): tabelinha + criação dos códigos
arquivo bpmn
usa java + parser java para xml
usa array de adjacencias, explicar?
%colocar diagrama de classes do parser, criar outra sessão específica e link para o java doc
%onde foram obtidos os diagramas de teste nesse trabalho

\subsection{Funcionamento}
O principal elemento para o funcionamento do parser é o SequenceFlow. Por conter os atributos “targetRef” e “sourceRef” os elementos do tipo SequenceFlow permitem percorrer todo o diagrama. Ao iniciar o parser, é solicitado ao usuário o caminho para o arquivo BPMN e a ID do processo a ser avaliado. Um diagrama pode conter mais de um processo e, nesse caso, o usuário pode escolher que todos processos sejam avaliados.
%- usertask e manualtask: nomes de tags padrão do bpms, quem quiser testar precisa alimentar o código com os nomes das tags a serem tratadas

\subsubsection{Tratamento e Análise do arquivo XML}
A primeira etapa do parser é tratar o arquivo XML para que ele possa ser lido pelo parser do Java. Algumas ferramentas exportam o diagrama para o formato BPMN inserindo um “tipo” antes no nome de cada tag XML, por exemplo, a tag de nome “task” pode estar representada como “bpmn2:task” e isso pode impedir que o parser do Java identifique os elementos. Assim, a primeira etapa do código é alterar notações deste tipo.

Após isso, é iniciada a avaliação de cada processo. O parser percorre os elementos do tipo sequenceFlow em busca das primeiras tarefas do processo, ou seja, tarefas que sucedem elementos do tipo startEvent. Para cada tarefa encontrada, será criado um objeto da classe definida como “Node” que contém informações básicas sobre os elementos e mais um array de adjacência. 

Então é feita a criação dos arrays de adjacência. No método chamado createNodes que retorna um objeto do tipo List<Node>, são percorridos todos os elementos sequenceFlow partindo das primeiras tarefas e, para cada nova tarefa encontrada, é criado um objeto da classe Node e então o método é chamado recursivamente para obter o array de adjacência do elemento em questão. O trecho de código referente a essa execução pode ser visto na Figura X. Este método é executado recursivamente até encontrar um elemento do tipo endEvent, ou seja, até encontrar um fim.

Assim, têm-se uma lista de objetos da classe Node. Os primeiros elementos desta lista serão, obrigatóriamente, as primeiras tarefas que foram encontradas no início da execução. Estes elementos teram as informações pertinentes mais o array de ajacências, que também é uma lista de objetos Node. Nesta lista estarão contidos todos os objetos da classe Node que sucedem a tarefa anterior.
%mostrar um exemplo, imagem

\subsubsection{Criação de artefatos para o teste funcional}
Após o documento XML ser devidamente analisado e as tarefas do processo esterem armazenadas no array de objetos Node, é possível criar os artefatos para auxiliar no teste funcional. Uma parte importante para esta etapa é identificar as últimas tarefas à serem executadas, ou seja, tarefas que antecedem um elemento do tipo endEvent. Estas tarefas irão auxiliar na criação dos possíveis caminhos pelos quais o processo pode passar.

Para criar os possíveis caminhos do processo, o array de adjacências obtido anteriormente é navegado recursivamente até encontrar uma condição de parada: a(s) últimos tarefas a serem executadas. Para cada chamada deste método, é recebido o array e os elementos pelos quais esse caminho passou anteriomente, ao encontrar a condição de parada, este novo caminho é armazenado e é iniciado um novo caminho. %método paths

Na criação dos caminhos, há uma exceção para quando existir uma divisão de fluxo através de um gateway do tipo inclusivo. Diferente do que acontece com o tipo exclusivo, onde apenas uma opção de pode ser seguida de cada vez, no caminho incluso as opções podem variar pois um ou mais caminhos podem ser seguidos ao mesmo tempo. Os caminhos em que apenas um fluxo é seguido já são cobertos pela execução normal, então, após a criação dos caminhos, é identificada a existencia de fluxos inclusivos e, se necessário, caminhos adicionais são inseridos.

A partir da criação dos caminhos, é chamado o método fillTable que percorre os caminhos para criar a tabela com os caminhos possíveis. No cabeçalho da tabela estarão presentes os nomes de todas as tarefas do processo e cada linha representa um caminho possível. O método fillTable ira percorrer todos os caminhos, comparando cada elemento do caminho com um elemento do processo, se o elemento faz parte deste caminho a coluna será marcada com um "X" caso contrário, a coluna será marcada com um "0". Ao final de toda a execução, a tabela será salva em um arquivo do tipo excel. Caso exista mais de um processo a ser analisado, as tabelas para cada processo estarão distribuídas individualmente no arquivo excel.
%exemplo de tabela

O segundo artefato criado é o código para o teste funcional, dois elementos essencias para o teste são criados: os esqueleto para os cenários de teste para o Cucumber e o esqueleto dos métodos na classe stepDefinition. 

-createFunctionalCode(paths, items, participantName); cria os cenarios e as definições dos passos
-só leva em conta tipos de tarefas que são executadas por pessoas -> já que quer fazer um teste funcional
    -para gerar o cenário e o stepdefinition - usertask e manualtask: nomes de tags padrão do bpms, quem quiser testar precisa alimentar o código com os nomes das tags a serem tratadas
	
-subprocess -> apenas como uma tarefa, normalmente sao simples, so testa o principal,subprocessos normalmente sao simples


- todos os cenario coloca no mesmo arquivo feature
- todas as definições coloca no mesmo stepdefinition

\subsection{Resultados}
%colocar um exemplo inteiro?

\subsection{Desvantagens?/Melhorias?}
-nomes de tags padrão do bpms, quem quiser testar precisa alimentar o código com os nomes das tags a serem tratadas
-tbm tem que tirar que que tem antes do nome da tag (ex: bpmn2:task), tem que colcoar no código
-como sao percorridos os sequenceflows, problemas com recursão, sem parada, ex: pizza.bpmn, para isso é colocado um "delimitador de recursao",  que controla o numero de vezes em que uma flechinha vai ser percorrida, o padrão é X e pode ser alterado conforme o tamanho do processo
-código em constante melhorias



\section{References}

%Bibliographic references must be unambiguous and uniform.  We recommend givingthe author names references in brackets, e.g. \cite{knuth:84},\cite{boulic:91}, and \cite{smith:99}.

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}
