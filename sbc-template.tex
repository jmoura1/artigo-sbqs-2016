
\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage[utf8]{inputenc}
\usepackage{graphicx,url}
%\usepackage[pdftex]{hyperref}
%\usepackage[pdftex]{hyperref}
\usepackage{listings}
\usepackage[brazil]{babel}   
%\usepackage[latin1]{inputenc}  


% http://justrocketscience.com/latex-gherkin-and-swift-highlighting
\lstdefinelanguage{Gherkin}{
  keywords={When, Then, Given, And},
  ndkeywords={Feature, Scenario},
  sensitive=false,
  comment=[l]{\#},
  morestring=[b]',
  morestring=[b]"
}
     
\sloppy

% Geração de Casos para.Testes Automatizados de Aplicações de Gerenciamento de Processos de Negócio a partir de Modelos em BPMN 
% de casos
% de código

% Geração de .. para Testes Funcionais Automatizados de Aplicações de Gerenciamento de Processos de Negócio Expressas em Notação BPMN 
\title{Geração de Casos para Testes Automatizados\\ de Aplicações de Gerenciamento de Processos de Negócio\\ a partir de Modelos em BPMN\\\vspace{0.5cm} \small{Trilha de Trabalhos Técnicos}}

%\title{Uma abordagem para geração de dados para Teste Funcional Automatizado de aplicações baseadas em Gerenciamento de Processos de Negócio apoiada na notação BPMN\\\vspace{0.5cm} \small{Trilha de Trabalhos Técnicos}}
%Uma estratégia para geração de códigos para Teste Funcional de ferramentas de Gerenciamento de Processos de Negócio
%Uma abordagem para melhoria do Teste Funcional Automatizado de aplicações de Gerenciamento de Processos de Negócio apoiada na notação BPMN
%apoiada em bpmn
%Uma abordagem para melhoria do Teste Funcional Automatizado de aplicações de Gerenciamento de Processos de Negócio apoiada na notação BPMN
%Uma abordagem para geração de dados para Teste Funcional Automatizado de aplicações de Gerenciamento de Processos de Negócio apoiada na notação BPMN

%http://cvs.labsoft.ufsc.br/publications/monografia_petroski.pdf
%http://www.lbd.dcc.ufmg.br/colecoes/sbes/1993/0022.pdf "Uma estratégia para geração de dados de teste"
%http://www.lbd.dcc.ufmg.br/colecoes/sbqs/2010/TT6_iure_fe.pdf Geração de Dados para Testes de Desempenho e Estresse a Partir de Testes Funcionais 


\author{Jéssica Lasch de Moura\inst{1}, Andrea Schwertner Charão\inst{1}}

%\address{Centro de Tecnologia -- Universidade Federal de Santa Maria
%  (UFSM)\\
 % Santa Maria -- RS -- Brazil
%\nextinstitute
 % Laboratório de Sistemas de Computação (LSC) -- Universidade Federal de Santa Maria\\  
  %\email{\{jmoura,andrea\}@inf.ufsm.br}
%}

\address{
  Laboratório de Sistemas de Computação (LSC)\\
  Universidade Federal de Santa Maria  
  \email{\{jmoura,andrea\}@inf.ufsm.br}
}
\begin{document} 

\maketitle

\begin{abstract}
%This paper describes an approach designed to get useful data for the execution of automated functional testing in Business Process Management tools with the support of BPMN notation. The %objective of this work was to facilitate and improve the scope of the tests, in order to improve the applications in question. With this approach, it was possible to obtain important %information about the processes and generate important elements for functional testing, making the test stage faster and more complete.

%This paper describes an approach designed to obtain data for the implementation of automated functional testing of applications based on Business Process Management using BPMN notation. The objective of this study was to extract information, through the analysis of BPMN files, for testing processes, in order that this information could assist in the creation and execution of tests. With this approach, it was possible to obtain data that have produced major elements for the test steps, helping to reduce the analysis time and create more complete testing.

This article proposes an approach to generate cases for automated testing of web applications implemented with the support of BPMS, from BPMN models, aiming to shorten the building test scripts effort. The work is primarily focused on functional testing and has the following objectives: (i) generate a table of application execution paths from the flow analysis in the BPMN model and (ii) generate the initial code of test scripts to be run on a given Web application testing framework.
Throughout the article, we describe the design and implementation of tools developed to achieve these goals, targeting the automation testing using Selenium and Cucumber tools. The approach was applied to a process repository and showed to be able to meet the necessary requirements.
\end{abstract}
     
\begin{resumo} 
% Com esta abordagem, foi possível obter informações importantes sobre os processos e gerar elementos importantes para o teste funcional, tornando a etapa de teste mais rápida e completa.

Este artigo propõe uma abordagem para geração de casos para testes automatizados de aplicações Web implementadas com o apoio de BPMS, a partir de modelos BPMN, visando abreviar o esforço de construção de \emph{scripts} de teste. O trabalho é focado principalmente em testes funcionais e tem como objetivos específicos: (i) gerar uma tabela de caminhos de execução da aplicação a partir da análise de fluxos no modelo BPMN e (ii) gerar o código inicial dos \emph{scripts} de teste, a serem executados em um dado arcabouço de teste de aplicações Web.
Ao longo do artigo, descreve-se o projeto e implementação de ferramentas desenvolvidas para atingir esses objetivos, tendo como alvo a automação de testes usando as ferramentas Selenium e Cucumber. A abordagem foi aplicada a um repositório de processos e mostrou-se capaz de cumprir os requisitos estabelecidos.


\end{resumo}

\section{Introdução}


Testes automatizados constituem um tema recorrente em comunidades interessadas em qualidade de software~\cite{Delamaro:2007, Dustin:2009}. Em comparação com testes manuais, a automação de testes de software pode trazer benefícios como, por exemplo, a repetibilidade, o aumento da cobertura e a redução do esforço na execução dos testes~\cite{Rafi:2012, sbqs2015:compara}. 
%Espera-se, com isso, atingir um patamar mais elevado de qualidade do software.
Quando executada satisfatoriamente, a automação de testes é vantajosa para reduzir o tempo desta etapa no ciclo de vida do software, diminuindo o custo e aumentando a produtividade do desenvolvimento como um todo, além de, principalmente, aumentar a qualidade do produto final.

Existem, no entanto, limitações associadas aos testes automatizados. Em um estudo abrangendo a academia e a comunidade de prática de testes de software, os principais problemas atribuídos aos testes automatizados foram relativos ao alto investimento inicial em configuração, escolha de ferramentas e treinamento da equipe~\cite{Rafi:2012}. Outro estudo nesta linha chama atenção para a dificuldade de criação de \emph{scripts} de teste~\cite{Wiklund:2014}.

Dentre as diversas classes de software que podem ser alvo de testes automatizados, tem-se as aplicações de gerenciamento de processos de negócio (\emph{Business Process Management} -- BPM). Designa-se por BPM o conjunto de conceitos, métodos e técnicas para suportar a análise, modelagem, execução, monitoramento e otimização dos processos de negócio~\cite{weske}. Nesse contexto, surgiram os sistemas de BPM (\emph{Business Process Management Systems} ou \emph{Suites} -- BPMS), que tipicamente oferecem  recursos para definição e modelagem de processos em BPMN (\emph{Business Process Model and Notation}), controle da execução e monitoramento de atividades dos processos~\cite{forrester}. Há uma tendência dos BPMS em abreviar o desenvolvimento de software~\cite{greenresearch}, oferecendo agilidade na produção de aplicações Web que executam os processos expressos em BPMN. 

Tarefas como verificação e testes ainda são consideradas um desafio na área de BPM~\cite{aalst2013survey}. De fato, o teste automatizado de aplicações de BPM é pouco abordado, tanto pela comunidade da área de BPM~\cite{weske} como da área de testes de software~\cite{graham2012experiences}. Em um trabalho anterior~\cite{sbqs2015}, buscou-se explorar este tema e constatou-se algumas dificuldades na realização de testes automatizados de carga e funcionais, em aplicações Web para execução de um mesmo processo, implementadas com o auxílio de dois BPMS \emph{open source} distintos: Bonita BPMS e Activiti. Os resultados corroboraram problemas já levantados por outros autores~\cite{Rafi:2012, Wiklund:2014}, além de apontar aspectos relacionados especificamente a aplicações Web criadas e executadas com o apoio de BPMS. Em particular, notou-se que a criação de \emph{scripts} de teste para processos com muitas tarefas poderia exigir um esforço demasiado. Neste contexto, buscando reduzir este esforço, tomou-se por hipótese que a criação de casos de teste para um dado processo poderia ser abreviada, usando como entrada o modelo BPMN de tal processo. 

Assim, o presente trabalho propõe uma abordagem para geração de casos para testes automatizados de aplicações Web implementadas com o apoio de BPMS, a partir de modelos BPMN, visando abreviar o esforço de construção de \emph{scripts} de teste. O trabalho é focado principalmente em testes funcionais e tem como objetivos específicos: (i) gerar uma tabela de caminhos de execução da aplicação a partir da análise de fluxos no modelo BPMN e (ii) gerar o código inicial dos \emph{scripts} de teste, a serem executados em um dado arcabouço de teste de aplicações Web.

O restante deste artigo está organizado como segue. Na seção \ref{sec:bpm}, apresenta-se uma fundamentação para o trabalho, apresentando-se conceitos e termos associados a BPM, seguidos de um embasamento sobre testes funcionais automatizados. A seção \ref{sec:related} discute trabalhos relacionados e, em seguida, a seção  \ref{sec:abordagem} apresenta a abordagem proposta, incluindo aspectos de projeto e implementação. Na seção \ref{sec:avaliacao} são apresentados resultados e exemplos obtidos na avaliação da abordagem. Por fim, a seção \ref{sec:conclusao} tece considerações finais sobre o trabalho.

%http://ieeexplore.ieee.org/xpl/articleDetails.jsp?arnumber=6823873&navigation=1
%Turning to the help requests, we found that the majority of the help requests were about designing test scripts and not about the areas that appear to be most problematic. From our results and previous publications, we see a clear need to simplify the use, installation, and configuration of test systems of this type. The problems attributable to software development tools suggest that testers implementing test automation need more skills in handling those tools, than historically has been assumed

%The survey showed that benefits of test automation were related to test reusability, repeatability, test coverage and effort saved in test executions. The limitations were high initial invests in automation setup, tool selection and training. Additionally, 45% of the respondents agreed that available tools in the market offer a poor fit for their needs. Finally, it was found that 80% of the practitioners disagreed with the vision that automated testing would fully replace manual testing.


%O teste funcional é um tipo de teste que permite verificar as saídas de um sistema produzidas a partir de entradas pré-definidas. Este tipo de teste permite testar as funcionalidades, requerimentos e regras de negócio presentes no software~\cite{molinari2003testes} verificando a existência de erros, o que auxilia na melhoria da qualidade do software.

%Uma das principais medidas para o teste de software é a cobertura de teste. A cobertura de teste mede a abrangência do teste e pode ser expressa pela cobertura dos casos de testes ou pela cobertura do código executado. Existem diversos trabalhos que abordam a importância da cobertura de testes de software~\cite{zhu1997software,bieman1996using}, inclusive ligando o crescimento da qualidade e confiabilidade do software ao crescimento da cobertura dos testes~\cite{malaiya2002software}.


%No entanto, as atividades executadas para criar testes funcionais com uma boa cobertura podem muitas vezes se tornar exaustivas e trabalhosas, dificultando assim a execução dos testes de forma adequada. Com o objetivo de melhorar a qualidade da análise e o tempo de execução dos testes, foram criados os testes automatizados, que proporcionam a execução dos testes mais rapidamente~\cite{fantinato2005autotest}. Quando executada corretamente, a automação de teste é uma das melhores formas de reduzir o tempo de teste no ciclo de vida do software, diminuindo o custo e aumentando a produtividade do desenvolvimento de software como um todo, além de, consequentemente, aumentar a qualidade do produto final.

%Para executar os testes funcionais automatizados em aplicações Web, pode-se utilizar ferramentas livres como Selenium~\cite{selenium}, Watir~\cite{watir} ou Geb~\cite{geb}. No trabalho anterior~\cite{sbqs2015}, onde os testes funcionais se mostraram mais promissores, foi utilizada a ferramenta Selenium, aliada ao Cucumber-JVM~\cite{cucumber} para descrição dos testes. A escolha foi motivada pelo grande número de referências ao Selenium na Web, confirmadas por um trabalho que apresentou resultados satisfatórios com Selenium e Cucumber~\cite{pannutest,sbqs2013}.




%A gestão de processos de negócio (\emph{Business Process Management} -- BPM) tem suscitado o interesse de empresas e da comunidade científica, tanto por seus benefícios quanto por seus desafios. Designa-se por BPM o conjunto de conceitos, métodos e técnicas para suportar a análise, modelagem, execução, monitoramento e otimização dos processos de negócio~\cite{weske}. \emph{BPMN} ou \emph{Business Process Management and Notation} é uma notação que fornece a capacidade de compreender processos de negócio em uma notação gráfica e a capacidade de exportar esses processos de uma forma padrão~\cite{bpmn}.

%Algumas tarefas como verificação e testes ainda são consideradas um desafio na área de BPM~\cite{aalst2013survey}. De fato, o teste automatizado de aplicações BPM é pouco abordado, tanto pela comunidade da área de BPM~\cite{weske} como da área de testes de software~\cite{graham2012experiences}. Devido a isso, em um trabalho anterior~\cite{sbqs2015} foram realizados testes de carga e teste funcional em uma aplicação BPM utilizando soluções já consagradas no teste de aplicações Web. Nesse trabalho anterior, o teste funcional utilizando as ferramentas Selenium e Cucumber se mostrou mais promissor.

%No trabalho anterior, também percebeu-se que a análise para obter os dados necessários para o teste funcional automatizado completo de uma aplicação pode ser complexa. Então, com a intenção de extrair dados importantes para o teste dos processos, decidiu-se por analisar os arquivos BPMN. 

%Optou-se por gerar uma tabela contendo os fluxos possíveis de cada processo, permitindo uma visão completa de como o processo é executado. Então foi criada uma abordagem para tratar os arquivos BPMN, gerar a tabela e, possivelmente, utilizar esses dados de forma a criar mais elementos importantes para o teste.

%Assim, o objetivo deste trabalho foi extrair informações, através da análise de arquivos BPMN, para o teste dos processos, com o propósito de que estas informações pudessem auxiliar na criação e execução de testes. 

\section{Fundamentação}\label{sec:bpm}
\subsection{Termos e Conceitos Associados a BPM} 
%\subsection{BPM, BPMS e BPMN} \label{sec:bpm}

O termo BPM pode ser usado com ênfases diferentes, dependendo do contexto. Em geral, é um termo usual em Administração e Engenharia de Produção, embora também seja de importância para as áreas de Computação e Tecnologia da Informação~\cite{sbqs2015:bpms}. Qualquer que seja a ênfase, há uma convergência de entendimento quanto ao ciclo de vida de aplicações de BPM, que engloba as atividades de análise, modelagem, execução, monitoramento e otimização de processos de negócio~\cite{ABPMP}. 

No suporte a esse ciclo de vida, os sistemas de BPM (BPMS) têm se afirmado como ferramentas essenciais. Desde as origens do termo BPMS~\cite{thirdwave:2003}, surgiu uma ampla diversidade de sistemas no mercado, incluindo desde BPMS proprietários de grandes fabricantes de software como IBM, SAP e Oracle, até sistemas com versões de código aberto, como por exemplo Bonita BPM, Activiti e Camunda. Tais ferramentas oferecem recursos para modelagem, controle de execução e monitoramento de processos, cada uma com suas especificidades. Esses e outros BPMS possuem atualmente um aspecto em comum: a representação de processos em BPMN.

% Atualmente, pode-se dizer que um típico BPMS oferece recursos para definição e modelagem de processos em BPMN, controle da execução e monitoramento de atividades dos processos~\cite{forrester}. Há uma tendência dos BPMS em abreviar o desenvolvimento de software, por exemplo através de geradores de formulários Web associados a tarefas dos processos~\cite{greenresearch}. 

%\subsection{Business Process Model and Notation - \emph{BPMN}}
O padrão \emph{Business Process Model and Notation}, ou BPMN, foi criado com o objetivo de ``\emph{fornecer uma notação facilmente compreensível por todos os usuários, desde os analistas que criam os rascunhos iniciais dos processos até os desenvolvedores responsáveis por implementar os processos e, finalmente, para os usuários que irão gerenciar e monitorar esses processos}''~\cite{model2011notation}. A versão BPMN 2.0, a mais recente, define um padrão XML para arquivos contendo dados sobre o modelo e o funcionamento do processo, bem como a sua representação visual~\cite{Kurz:2016}. Isto permite que o XML seja analisado para obter-se informações sobre os processos. A maioria dos BPMS disponibiliza a exportação do processo em formato XML, seguindo o padrão BPMN. No padrão BPMN, um processo é descrito como um diagrama de elementos de fluxo, que são: Tasks (Tarefas), Events (Eventos), Gateways e Sequence Flows. Na Figura \ref{fig:bpmn}, podem ser vistos os principais elementos que compõem um diagrama BPMN e que serão importantes para este trabalho.

\begin{figure}[ht]
\centering
\includegraphics[width=.5\textwidth]{figuras/newbpmn.png}
\caption{Principais elementos de um processo de acordo com o padrão BPMN}
\label{fig:bpmn}
\end{figure}

As \emph{Activities} constituem a menor parte de um diagrama em BPMN, sendo utilizadas quando o diagrama não pode ser dividido mais detalhadamente. Quando uma \emph{Activity} está inserida no contexto de um processo, ela é chamada de \emph{Task}. Geralmente as \emph{Tasks} são executadas por um usuário final ou por uma aplicação. Existem diferentes tipos de \emph{Tasks} para representar os diferentes comportamentos de cada tarefa. Por exemplo, uma \emph{User Task} representa uma tarefa em que um usuário deve executar uma ação. Um elemento do tipo \emph{SubProcess} é uma abstração de um pequeno conjunto de \emph{Tasks}.
%represent. The list of Task types MAY be extended along with any corresponding indicators. \emph{userTask},\emph{manualTask}.

%events
Um \emph{Event} é algo que ``acontece'' durante o curso de um processo~\cite{model2011notation}. Existem três tipos principais de eventos: \emph{Start Event} (indica o início do processo), \emph{End Event} (indica um fim do processo) e \emph{Intermediate Event} (indica um evento entre o início e o fim do processo).

%gateways
\emph{Gateways} são usados para controlar o fluxo do processo. Em \emph{Gateways} do tipo \emph{Exclusive}, apenas um dos fluxos que partem do \emph{Gateway} poderão ser seguidos, já em \emph{Gateways} do tipo \emph{Inclusive} um ou mais fluxos podem ser seguidos. Em \emph{Gateways} do tipo \emph{Parallel}, todos os fluxos são executados ao mesmo tempo.

%A Parallel Gateway is used to synchronize (combine) parallel flows and to create parallel flows.? The Parallel Gateway MUST use a marker that is in the shape of 
%plus sign and is placed within the Gateway
%diamond (see Figure 10.110) to distinguish it from other Gateway

%sequence flows
Um \emph{Sequence Flow} é usado para exibir a ordem em que os demais elementos são executados em um processo. Cada \emph{Sequence Flow} possui apenas uma origem (ou fonte) e um destino (ou alvo), que podem ser \emph{Activities}, \emph{Events} ou \emph{Gateways}. Analisando os elementos \emph{Sequence Flow} de um diagrama, é possível identificar todo o fluxo de execução do processo.


\subsection{Testes Funcionais Automatizados de Aplicações Web}

% Introducao ao teste de software
%http://www.sciencedirect.com/science/book/9788535226348
% Molinari
%http://www.visualbooks.com.br/shop/sumarios/01121.pdf

Teste funcional é uma técnica de teste que permite verificar as saídas de um sistema produzidas a partir de entradas pré-definidas. Este tipo de teste permite testar as funcionalidades, requisitos e regras de negócio presentes no software~\cite{Delamaro:2007}, verificando a existência de erros e, com isso, auxiliando na melhoria da qualidade do software.

Uma das principais medidas para o teste de software é sua cobertura. A cobertura de teste mede sua abrangência e pode ser expressa pela cobertura dos casos de testes ou pela cobertura do código executado. Existem diversos trabalhos que abordam a importância da cobertura de testes de software~\cite{zhu1997software, bieman1996using}, inclusive ligando o crescimento da qualidade e confiabilidade do software ao crescimento da cobertura dos testes~\cite{malaiya2002software}.



% Estava repetitivo:
%dificultando assim a execução dos testes de forma adequada. Com o objetivo de melhorar a qualidade da análise e o tempo de execução dos testes, foram criados os testes automatizados, que proporcionam a execução dos testes mais rapidamente~\cite{fantinato2005autotest}. 

%Quando executada corretamente, a automação de teste é uma das melhores formas de reduzir o tempo de teste no ciclo de vida do software, diminuindo o custo e aumentando a produtividade do desenvolvimento de software como um todo, além de, consequentemente, aumentar a qualidade do produto final.

Criar testes funcionais com uma boa cobertura pode se tornar uma tarefa exaustiva e trabalhosa, motivando a realização de testes funcionais automatizados. Com a popularização de aplicações Web, no entanto, testes automatizados revelaram novos desafios, devido à natureza distribuída, a heterogeneidade e a dinamicidade das aplicações~\cite{webtest:2013}. Estas características estão presentes em grande parte das aplicações de BPM construídas com o apoio de BPMS, uma vez que a maioria destes sistemas é voltado para a Web. Porém, testes automatizados de software não fazem parte dos recursos comumente oferecidos pela maioria dos BPMS, restando assim a opção de se utilizar ferramentas de testes automatizados voltadas para aplicações Web em geral.

Para executar os testes funcionais automatizados em aplicações Web, pode-se utilizar ferramentas livres como Selenium~\cite{selenium}, Watir~\cite{watir} ou Geb~\cite{geb}. Em um trabalho anterior~\cite{sbqs2015}, os testes funcionais utilizando a ferramenta Selenium, aliada ao Cucumber-JVM~\cite{cucumber}, se mostraram promissores quando aplicados a etapas de um processo construído com dois diferentes BPMS. A escolha dessas ferramentas foi motivada pelo grande número de referências ao Selenium em fóruns especializados, corroboradas em trabalhos acadêmicos~\cite{sbqs2013, sbqs2015:compara}. Assim, manteve-se essa escolha no presente trabalho.

\subsubsection{Testes Automatizados com \emph{Selenium} e \emph{Cucumber-JVM}}

O processo para a realização de um teste funcional utilizando o Selenium aliado ao Cucumber-JVM é composto de cinco etapas: captura da interação do usuário com a aplicação e exportação do código gerado, criação dos cenários de teste, criação das definições dos passos de teste, implementação dos métodos para cada passo e, por fim, execução do teste.

Para efetuar a captura da interação do usuário com a aplicação é utilizado o Selenium IDE (\emph{Integrated Development Environment}), que permite gravar as ações do usuário conforme elas são executadas. Assim, a funcionalidade que deseja ser testada deve ser executada para que os passos sejam gravados. Após a captura da interação é possível exportar o \emph{script} utilizando diversas linguagens de programação disponíveis. No presente trabalho, como forma de delimitá-lo, utiliza-se somente a linguagem Java.
%, neste caso foi escolhida a linguagem Java.

Os testes utilizando Cucumber são compostos, basicamente, por dois arquivos: arquivos que especificam as funcionalidades (\emph{features}) e por arquivos de definição de passos (\emph{steps}). 

Os arquivos com as funcionalidades (\emph{features}) são escritos na linguagem Gherkin~\cite{gherkin} e são compostos por cenários. Os cenários representam uma fração da aplicação que vai ser testada. Um cenário também pode ser descrito como a definição, em ordem de execução, das etapas que são executadas nessa fração, bem como dos resultados esperados para validar a aplicação. Por exemplo, após um \emph{Gateway} exclusivo com dois fluxos disponíveis, tem-se dois cenários possíveis, um cenário executando cada fluxo. 
%Por exemplo, para testar apenas o login em uma aplicação, já é possível obter dois cenários possíveis: (a) dados de acessos corretos e sucesso no login e (b) dados de acesso incorretos e mensagem de erro. 

Para que cada etapa do cenário seja executada, é necessária a criação de \emph{steps} que irão traduzir os passos definidos na linguagem Gherkin para ações que vão interagir com o sistema. Cada \emph{step}, geralmente, invocará um método em Java que irá efetivamente executar a interação com a aplicação. A implementação destes métodos pode ser feita apenas utilizando o código extraído através do Selenium após a captura das ações do usuário.

Assim, mesmo utilizando Cucumber e Selenium para facilitar a criação dos testes, ainda é preciso analisar o processo e extrair os cenários de teste que devem ser criados manualmente no arquivo de \emph{features}. Além dos cenários, também deve ser criado manualmente o arquivo de \emph{steps}, contendo um ``passo'' correspondente a cada etapa de todos os cenários criados. Esta etapa pode ser trabalhosa, principalmente quando for necessário testar diversos cenários que um processo pode ter ou quando o processo for extenso.



%Assim, o presente trabalho propõe uma abordagem para geração de casos para testes automatizados de aplicações Web implementadas com o apoio de BPMS, a partir de modelos BPMN, visando abreviar o esforço de construção de \emph{scripts} de teste. O trabalho é focado principalmente em testes funcionais e tem como objetivos específicos: (i) gerar uma tabela de caminhos de execução da aplicação a partir da análise de fluxos no modelo BPMN e (ii) gerar o código inicial dos \emph{scripts} de teste, a serem executados em um dado arcabouço de teste de aplicações Web.


\section{Trabalhos Relacionados}\label{sec:related}

Os sistemas BPM geralmente oferecerem recursos para definição e modelagem de processos em BPMN, controle da execução e monitoramento de atividades dos processos~\cite{forrester}. Nota-se, no entanto, que a preocupação com testes não fica evidente nas ferramentas BPMS. De fato, examinando-se o material promocional e a documentação disponível sobre os principais BPMS, observa-se uma ênfase em etapas de modelagem e execução. Visivelmente, tais recursos são um diferencial no desenvolvimento de aplicações de BPM, em comparação ao desenvolvimento de software em geral. No entanto, aplicações de BPM também estão sujeitas a defeitos e, por isso, podem se beneficiar de avanços na área de testes de software.

Existem trabalhos que chamam a atenção para a importância e para a as dificuldades trazidas pela execução de testes, bem como trazem alternativas para a melhoria da seleção de casos de teste~\cite{bohmer2015genetic}. Esses trabalhos fortalecem a ideia da importância de informações para facilitar a criação de testes para processos ou sistemas BPM, no entanto, os trabalhos geralmente abordam a criação de casos de teste baseados em modelos de processo e não em sistemas em si. Também não é descrita uma forma de automatizar ou executar os casos de teste criados. Existem também trabalhos que visam maneiras de automatizar e melhorar o monitoramento da conformidade dos modelos de processos~\cite{ly2015compliance, van2012replaying} e que, novamente, são mais voltados para os processos em si e sua administração do que para sistemas/software.


\section{Abordagem Proposta}\label{sec:abordagem}

O objetivo deste trabalho é auxiliar na geração de casos para testes funcionais automatizados de aplicações Web construídas com o apoio de BPMS, a partir de modelos BPMN. Neste sentido, um aspecto importante para o teste funcional é identificar quais fluxos ou etapas serão testadas, pois estes determinam caminhos de execução da aplicação e podem definir ou limitar o teste, interferindo assim na qualidade e na cobertura dos testes. 

Com o objetivo de obter informações capazes de auxiliar na identificação dos fluxos, projetou-se e implementou-se uma ferramenta que analisa os arquivos XML no formato BPMN, exportados por ferramentas BPMS.  Para tratar essas informações, optou-se por analisar o processo de modo a transformá-lo em uma tabela contendo todos os possíveis fluxos que podem ser executados no processo, para então permitir que sejam realizadas outras análises. A partir da tabela, pode-se gerar outros elementos, conforme a necessidade de cada domínio. Neste trabalho, aproveita-se os resultados da tabela de fluxos como entrada para uma ferramenta concebida e implementada para gerar o código inicial dos \emph{scripts} de teste, para uso com Selenium e Cucumber. Uma visão geral desta abordagem é ilustrada na Figura \ref{fig:abordagem1}, em que as etapas de análise do XML e de tratamento de resultados da tabela correspondem a funcionalidades das ferramentas implementadas, descritas nas seções a seguir.

%Além das análises que a própria tabela possibilita, também é possível utilizar a estratégia criada para gerar outros elementos conforme a necessidade de cada domínio. No caso deste trabalho, por o teste funcional automatizado utilizando o Selenium e o Cucumber se mostrou promissor em um trabalho anterior~\cite{sbqs2015}, decidiu-se por avaliar a possibilidade de aproveitar a abordagem criada para também gerar elementos importantes para o teste: o arquivo de \emph{features} contendo os cenários cenários e o arquivo de \emph{steps}.


\begin{figure}[ht]
\centering
\includegraphics[width=.9\textwidth]{figuras/abordagemTotal2.png}
\caption{Visão geral da abordagem proposta}
\label{fig:abordagem1}
\end{figure}



%colcoar imagem aqui

\subsection{Geração da Tabela de Fluxos}

Para analisar um arquivo BPMN, foi elaborada uma estratégia que percorre sua representação em XML e manipula as informações necessárias. Enquanto o arquivo é percorrido, os elementos BPMN são analisados através da nomenclatura padrão especificada nas \emph{tags} XML. Ao fim da execução, é gerado um arquivo em formato Excel, contendo uma tabela com todos os possíveis cenários/fluxos do processo. Na implementação da ferramenta de análise, foi utilizada a linguagem Java, que possui uma opção de API consolidada para a análise de documentos XML (JAXP).
%~\cite{javadom}.
% e então é executada uma lógica para criar os diferentes cenários de teste. 

O elemento BPMN mais importante para a análise é o \emph{Sequence Flow}. Cada \emph{Sequence Flow} possui um atributo \texttt{sourceRef}, que indica de onde este \emph{Sequence Flow} vem, ou sua ''fonte'', e um atributo \texttt{targetRef}, que indica para onde ele vai, ou seja, seu alvo. Por conter esses atributos, os elementos deste tipo permitem percorrer todo o diagrama. Ao iniciar a execução da ferramenta de análise, é solicitado ao usuário o caminho para o arquivo BPMN e a ID do processo a ser avaliado. Um diagrama pode conter mais de um processo e, nesse caso, o usuário pode escolher que sejam analisados todos ou somente alguns processos.

Na implementação da ferramenta, foi criada a classe \emph{Node} que define um tipo de objeto que guarda informações básicas sobre as tarefas do processo e um \emph{array} de objetos dessa classe. Durante a execução, esse \emph{array} de objetos da classe Node é preenchido, formando assim um \emph{array} de adjacências. O método principal percorre o processo recursivamente através dos elementos do tipo \emph{Sequence Flow}. Enquanto houver tarefas encontradas no XML, um objeto da classe Node é criado e o método é chamado recursivamente de modo a retornar o \emph{array} de adjacências para este objeto.

A partir do \emph{array} de adjacências, são criados os fluxos possíveis pelos quais o processo pode passar. O método que cria os fluxos percorre recursivamente o \emph{array} de adjacências criado anteriormente e ``constrói'' um novo fluxo possível, tendo como condição de parada o encontro de uma das últimas tarefas a serem executadas. Uma tarefa é uma das últimas quando o elemento que a sucede no fluxo for elemento do tipo\emph{End Event}. Ao encontrar uma tarefa final, a informação é armazenada e é iniciada a construção de um novo fluxo possível.



Para criar a tabela de fluxos, cada tarefa existente no processo representará uma coluna na tabela e cada fluxo representará uma nova linha. Para cada fluxo, se a tarefa estiver presente a coluna será marcada com ``X'', caso contrário a coluna será marcada com um ``-''. Caso mais de um processo seja avaliado ao mesmo tempo, a tabela referente a cada processo estará separada individualmente no arquivo final. 

Na Figura \ref{fig:diagram5}, pode ser visto um resultado da execução da ferramenta de análise para um exemplo de processo, que possui cinco \emph{Tasks} e dois fluxos possíveis. Com a geração desta tabela, podem ser realizadas diversas análises sobre o processo: número de fluxos possíveis, identificar gargalos, dentre outras.

\begin{figure}[ht]
\centering
\includegraphics[width=.9\textwidth]{figuras/diagram5.png}
\resizebox{\textwidth}{!}{%
\begin{tabular}{ccccc}
\hline
\multicolumn{1}{l}{Quotation Handling} & \multicolumn{1}{l}{Approve Order} & \multicolumn{1}{l}{Order Handling} & \multicolumn{1}{l}{Shipping Handling} & \multicolumn{1}{l}{Review Order} \\
\hline
X & X & - & - & - \\
X & X & X & X & X\\
\hline
\end{tabular}
}

\caption{Exemplo de processo analisado e a tabela de fluxos resultante}
\label{fig:diagram5}
\end{figure}



\subsection{Dificuldades e Limitações da Análise}

A maioria das dificuldades de implementação da ferramenta de análise são relacionadas à estrutura dos processos e como a implementação interpretaria essas características. Na criação dos fluxos possíveis, uma dificuldade ocorreu devido aos desvios causados por elementos do tipo \emph{Gateway}. Para isso, para cada Node criado no \emph{array} é guardado o tipo do elemento que o antecede. Assim, na criação dos fluxos, elementos que partem de um desvio de fluxo precisaram ser tratados para criar os fluxos corretamente, por exemplo: se dois elementos, X e Y, vêm de um \emph{Gateway} do tipo exclusivo, os fluxos obtidos até estes elementos serão duplicados, ou seja, metade dos fluxos passarão apenas por X e metade dos fluxos passarão apenas por Y.

No caso de \emph{Gateways} do tipo paralelo, onde os fluxos são executados ao mesmo tempo, foi necessária fazer uma escolha para representar estes fluxos na tabela. Assim, decidiu-se por expressar cada fluxo em paralelo separadamente. Estimou-se que esta opção facilitaria na visualização dos fluxos para os testes já que, para a execução dos testes funcionais automatizados, é analisado cada fluxo como um ``cenário'' diferente.

%Na criação dos fluxos, há uma exceção para quando existir uma divisão de fluxo através de um gateway do tipo inclusivo. Diferente do que acontece com o tipo exclusivo, onde apenas uma opção de pode ser seguida de cada vez, no \emph{gateway} inclusivo as opções podem variar pois um ou mais fluxos podem ser seguidos ao mesmo tempo. Os casos em que apenas um fluxo é seguido já são cobertos pela execução normal do parser, então, após a criação dos fluxos, é identificada a existencia de casos inclusivos e, se necessário, fluxos adicionais são inseridos.

Devido ao fato da estratégia implementada ser executada recursivamente e percorrer o processo baseado no fluxo dos elementos do tipo \emph{Sequence Flow}, ocorreram problemas em processos onde uma parcela do processo também é executada recursivamente. Estes problemas foram causados devido ao fluxo nunca encontrar um ``fim''. Para solucionar esses problema foi criado um ``delimitador de recursão'' que define e controla o número de vezes em que o mesmo \emph{SequenceFlow} será executado.

Algumas ferramentas exportam o diagrama para o formato BPMN inserindo um ``tipo'' antes no nome de cada \emph{tag} XML. Por exemplo, a \emph{tag} de nome \texttt{task} pode estar representada como ``\texttt{semantic:task}'' e isso pode impedir que o \emph{parser} XML do Java identifique os elementos. Assim, foi necessário preparar métodos para tratar este tipo de situação, removendo os elementos encontrados antes dos nomes de \emph{tags}.

Apesar de utilizarem o padrão BPMN, algumas ferramentas podem utilizar nomes diferentes para representar tarefas no arquivo XML. Por isso, dependendo do BPMS que for utilizado para definir o processo, pode ser necessário substituir o nome das tarefas tratadas diretamente no código XML.

%pode gerar fluxos iguais, por remover boa parte das tarefas, como pdoe ser visto na figura de antes também

%-subprocess -> apenas como uma tarefa, normalmente sao simples, so testa o principal,subprocessos normalmente sao simples


%\section{Teste Funcional de Software e criação de códigos para os testes}\label{sec:testefuncional}


\subsection{Geração de Código para os Testes Funcionais}

A tabela de fluxos contém informações úteis para a criação de \emph{scripts} de teste. A partir dela, pode-se automatizar a geração de elementos importantes para testes usando Selenium e Cucumber: o arquivo de \emph{features},  contendo os cenários de teste, e o arquivo de \emph{steps}.

%\begin{figure}[ht]
%\centering
%\includegraphics[width=.9\textwidth]{figuras/abordagem2.png}
%\caption{Uma das opções de uso da abordagem: geração de códigos para o teste funcional}
%\label{fig:abordagem2}
%\end{figure}

O arquivo contendo os cenários de teste é essencial para o teste funcional com Cucumber, no entanto a criação dos arquivos de \emph{features} contendo os cenários e do arquivo de \emph{steps} pode ser trabalhosa, como já foi mencionado. Assim, de acordo com a visão geral da abordagem proposta (Figura \ref{fig:abordagem1}), a tabela resultante da análise do arquivo BPMN pode ser processada para gerar os arquivos com códigos, que posteriormente deverão ser completados para se tornarem \emph{scripts} de teste completos. 

Para criar estes arquivos, a ferramenta de geração de código faz um tratamento dos resultados da tabela de fluxos. Cada fluxo que foi obtido na análise, e que consta na tabela de fluxos, foi considerado um cenário diferente. Como se trata de testes funcionais, apenas tarefas que podem ser executadas por um usuário foram ser avaliadas (\texttt{userTask},\texttt{manualTask}...). Assim, para cada fluxo é criado um novo cenário no arquivo de \emph{features}, utilizando a notação do Cucumber, e contemplando apenas as tarefas que podem ser executadas por um usuário. O método correspondente a cada passo do cenário é criado ao mesmo tempo e inserido no arquivo de \emph{steps}. %Na Figura \ref{fig:exemplo_cenario}, podem ser vistos dois cenários resultante da execução do parser para um processo com dois fluxos possíveis. 

%colocar código aqui
%\begin{figure}[ht]
%\centering
%\includegraphics[width=.5\textwidth]{figuras/exemplo_cenario.png}
%\caption{Exemplo de cenários resultantes}
%\label{fig:exemplo_cenario}
%\end{figure}




%--------------------------------------------------------------------
\section{Avaliação}\label{sec:avaliacao}
%--------------------------------------------------------------------
Para avaliar a abordagem proposta, foram buscados processos já existentes, de diferentes domínios, contendo ao menos três tarefas e uma divisão de fluxo com ou sem \emph{Gateways}. Procurou-se também processos que tivessem algumas diferenças de notação, para verificar como a solução implementada trataria essas diferenças. Visando utilizar um repositório de processos amplamente acessível, os processos escolhidos foram obtidos no \emph{site} da \emph{Object Management Group} (OMG) e estão disponíveis em \url{http://www.omg.org/spec/BPMN/20100602/2010-06-03/}.

A Tabela \ref{tab:resumoprocessos} apresenta uma visão geral dos processos utilizados na avaliação. As informações referentes ao número de tarefas e de fluxos foram extraídas das tabelas geradas pela ferramenta desenvolvida. Esses números foram conferidos manualmente e estão de acordo com os diagramas dos processos.  A divisão de fluxos é importante para os testes, pois delimita quantos fluxos existem no processo, ou seja, quantos fluxos podem ser testados.


%\begin{table}[]
%\centering
%\caption{Resumo dos processos avaliados}
%\label{tab:resumoprocessos}
%\resizebox{\textwidth}{!}{%
%\begin{tabular}{cccc}
%\hline
%Número de tarefas & Número de Gateways & Tipo do Gateway                 & Fluxos possíveis \\
%\hline
%3                 & 0                  & Sem divisão de fluxos           & 1                \\
%3                 & 1                  & Exclusivo                       & 2                \\
%4                 & 0                  & Divisão de fluxos sem Gateways  & 2                \\
%5                 & 0                  & Divisão de fluxos sem Gateways  & 3                \\
%5                 & 1                  & Exclusivo                       & 3                \\
%6                 & 2                  & Exclusivo                       & 3                \\
%7                 & 1                  & Exclusivo                       & 2                \\
%8                 & 3                  & Inclusivo, Exclusivo e Paralelo & 3                \\
%8                 & 3                  & Paralelo, Exclusivo e Inclusivo & 5                \\
%10                & 1                  & Exclusivo                       & 2\\
%\hline
%\end{tabular}
%}
%\end{table}


\begin{table}[htb]
\centering
\caption{Resumo dos processos utilizados na avaliação}
\label{tab:resumoprocessos}
\resizebox{\textwidth}{!}{%
\begin{tabular}{lcccc}
\hline
Nome do Processo & Número de & Número de & Tipo de  & Fluxos  \\
                 & tarefas & Gateways & Gateway &  possíveis \\
\hline
Hardware Retailer & 8 & 3 & Paralelo, Exclusivo e Inclusivo & 5 \\
Nobel Prize -- Nobel Assembly & 3 & 0 & Sem divisão de fluxos & 1 \\
Incident Management (Whole Collab) -- & 3 & 1 & Exclusivo & 2 \\
~~~~~2nd level support agent &  &  &  &  \\
Incident Management (Whole Collab) --  & 6 & 2 & Exclusivo & 3 \\
~~~~~Trouble Ticket System &  &  &  &  \\
Nobel Prize - Nobel Commitee for medicine & 10 & 1  & Exclusivo & 2\\
%Processo 1 & 4  & 0 & Divisão de fluxos sem Gateways  & 2 \\
%Processo 3 & 5 & 0  & Divisão de fluxos sem Gateways  & 3 \\
Order Fulfillment & 7 & 1  & Exclusivo  & 2 \\
Pizza - Pizza Customer & 5 & 1 & Exclusivo & 2 \\
%Processo 3 & 8 & 3 & Inclusivo, Exclusivo e Paralelo & 3  \\
Travel Booking & 10 & 4  & Exclusivo & 7\\
\hline
\end{tabular}
}
\end{table}


% Parágrafo em stand-by (ver se fica melhor aqui no início ou no final)
%Pode-se dizer que, quanto maior o número de fluxos possíveis, mais complexa é a análise para a criação dos testes. Assim, os elementos gerados automaticamente são úteis à medida que avançam algumas etapas nessa análise. Outro ponto importante é que, em alguns casos, podem existir divisões de fluxo sem \emph{Gateways}. As divisões sem \emph{Gateways}, dependendo da ferramenta BPMS utilizada para gerar o processo, só podem ser visualizadas através da análise do documento. Isso pode atrapalhar a análise ``manual'', mas a abordagem adotada permite que essas divisões sejam detectadas e tratadas automaticamente.

Com a análise de um arquivo BPMN através da ferramenta desenvolvida, é possível obter uma tabela relacionando as tarefas e os fluxos possíveis dentro do processo. Por exemplo, o processo na Figura \ref{fig:diagrama_exemplo} possui \emph{Gateways} de diferentes tipos, gerando assim várias divisões de fluxo e aumentando os fluxos que podem ser seguidos. 

\begin{figure}[ht]
%\centering
\includegraphics[width=1.0\textwidth]{figuras/diagrama_exemplo.png}
\caption{Diagrama do processo ``Hardware Retailer''. Fonte: OMG}
\label{fig:diagrama_exemplo}
\end{figure}

%Fonte: \url{http://www.omg.org/spec/BPMN/20100602/2010-06-03/Hardware\%20Retailer/
Ao executar a ferramenta sobre o arquivo BPMN referente ao processo da Figura \ref{fig:diagrama_exemplo}, foi obtida a Tabela \ref{tab:resultado}. Nesta tabela, cada coluna representa uma tarefa do diagrama e cada linha representa um fluxo possível, facilitando a visualização do processo. A geração da tabela pode auxiliar a reduzir o tempo de análise necessário para executar o teste funcional dos processos, possibilitando que os fluxos possíveis sejam vistos rapidamente. 

A tabela também permite que sejam feitas análises importantes para o teste funcional do processo como, por exemplo: identificar gargalos, identificar quais tarefas são executadas mais frequentemente, identificar os caminhos mais importantes para os testes, entre outros. Por exemplo, na Tabela \ref{tab:resultado} pode-se dizer que o teste da primeira e da última tarefa do processo é importante, pois a grande maioria dos fluxos possíveis passarão por essas tarefas. Da mesma forma que permite análises importantes para os testes, a tabela gerada também auxilia na criação de testes mais completos, pois permite visualizar todos os fluxos possíveis de serem testados dentro de um processo.

\begin{table}[]
\centering
\caption{Tabela obtida através do arquivo BPMN}
\label{tab:resultado}
\resizebox{\textwidth}{!}{%
\begin{tabular}{cccccccc}
%Decide if normal post or special shipment & Request quotes from carriers & Assign a carrier \& prepare paperwork & Check if extra insurance is necessary & Take out extra insurance & Fill in a Post label & Package goods & Add paperwork and move package to pick area \\
\hline
Decide & Request & Assign & Check & Take out  & Fill in...& Package  & Add \\
if normal... & quotes... & a carrier...& if extra... & extra insurance & & goods & paperwork ...\\
\hline
X & X & X & - & - & - & - & X \\
X & - & - & X & X & - & - & X \\
X & - & - & X & - & X & - & X \\
- & - & - & - & - & - & X & X \\
X & - & - & X & X & X & - & X\\
\hline
\end{tabular}%
}
\end{table}

Nesse trabalho também é abordada a criação, a partir da tabela gerada, de códigos para teste funcional de processos utilizando as ferramentas de automação Selenium e Cucumber-JVM. Para executar o teste completo do processo, testando todas as possibilidades e representando as informações obtidas na tabela, seria necessário planejar os cenários de teste e criá-los manualmente. Para criar os cenários, também é necessário identificar quais tarefas são executadas por um usuário em um processo que possui várias \emph{Tasks}. Por fim, também seria necessário criar os \emph{steps} para cada etapa do cenário manualmente.

Executando a ferramenta desenvolvida sobre o arquivo BPMN referente ao diagrama da Figura \ref{fig:diagrama_exemplo}, obtém-se os cenários de teste representados no trecho da Figura \ref{fig:cenarios}. 

\begin{figure}[ht]
\centering
\begin{lstlisting}[language=Gherkin,frame=single,basicstyle=\footnotesize\ttfamily]
Feature: Testing BPM Processes  
 
Scenario: Hardware Retailer 0 
Given I am on task Decide if normal post or special shipment 
When 
Then 
When I am on task Assign a carrier & prepare paperwork 
Then 
When I am on task Add paperwork and move package to pick area 
Then 
 
Scenario: Hardware Retailer 1 
Given I am on task Decide if normal post or special shipment 
When 
Then 
When I am on task Check if extra insurance is necessary 
Then 
When I am on task Add paperwork and move package to pick area 
Then 
 
Scenario: Hardware Retailer 2
When I am on task Package goods 
Then 
When I am on task Add paperwork and move package to pick area 
Then 
\end{lstlisting}
\caption{Cenários de teste gerados}
\label{fig:cenarios}
\end{figure}

Para o teste funcional do processo em questão, três cenários são possíveis, representando as duas principais divisões de fluxo encontradas no processo. A primeira divisão de fluxo, formada pelo \emph{Gateway} do tipo paralelo logo no início do processo, está contida no cenário de forma que os cenários \emph{Hardware Retailer 0} e \emph{Hardware Retailer 1} fazem parte de um fluxo e o cenário \emph{Hardware Retailer 2} representa o segundo fluxo possível. A segunda divisão de fluxo no processo da Figura \ref{fig:diagrama_exemplo} é formada pelo \emph{Gateway} do tipo exclusivo, e essa divisão é representada pelos cenários \emph{Hardware Retailer 0} e \emph{Hardware Retailer 1}. Há ainda uma terceira divisão de fluxo no processo, mas esta divisão não foi levada em conta pela ferramenta pois as tarefas subsequentes a essa divisão não são tarefas executadas pelo usuário.

Para cada etapa nos cenários criados, é criado um método correspondente dentro do arquivo de \emph{steps}, chamado \texttt{StepsDefinition}. Uma parte do arquivo de \emph{steps} resultante da análise do processo em questão pode ser visto na Figura \ref{fig:codigojava}. Como pode ser visto neste código, para a etapa de cenário chamada \emph{I am on the task Decide if normal post or special shipment} foi criado um método com um nome genérico e contendo a anotação \emph{@Given("\^{}I am on the task Decide if normal post or special shipment\textdollar{}")}. Os métodos podem ser preenchidos posteriormente, com os dados gravados pelo Selenium na etapa de captura da interação com a aplicação.

\begin{figure}[ht]
\centering
\begin{lstlisting}[language=Java,frame=single,basicstyle=\footnotesize\ttfamily]
import cucumber.api.java.en.*;
import cucumber.runtime.PendingException;
public class StepsDefinition{
@Before
public void beforeScenario(){}
@After
public void afterScenario(){} 
//Methods for process Hardware Retailer
@Given("^I am on the task Decide if normal post or special shipment$") 
public void method0() throws Exception {} 
@when("^name$") 
public void method1() throws Exception {} 
@Then("^name$") 
public void method2() throws Exception {} 
@When("^I am on the task Assign a carrier & prepare paperwork$") 
public void method3() throws Exception {} 
\end{lstlisting}
\caption{Trecho do arquivo de \emph{steps} resultante}
\label{fig:codigojava}
\end{figure}

Neste exemplo, apenas um processo foi analisado, mas arquivos BPMN podem conter vários processos. Caso seja necessário gerar os dados para todos os processos dentro de um arquivo, o arquivo contendo a tabela resultante será composto por várias tabelas, uma para cada processo analisado. Como é gerado o código de teste referente a todos os fluxos que contêm \emph{Tasks} executadas por usuários, é possível executar o teste para todos os fluxos ou, por outro lado, também é possível utilizar a tabela gerada para verificar quais os fluxos mais importantes e utilizar os códigos gerados referentes apenas a esses fluxos.

Nesse trabalho, foi possível obter uma tabela importante para o teste dos processos, permitindo que sejam obtidas informações úteis para a execução de testes completos e com boa cobertura. As informações geradas também podem auxiliar na análise e a reduzir o tempo necessário para efetuar os testes. Como um exemplo de utilização dos dados obtidos, foram gerados dois arquivos essenciais para o teste funcional automatizado de aplicações BPM: o arquivo com os cenários de teste e o arquivo com os métodos para executar cada etapa dos cenários. %Assim, pode-se dizer que foi possível obter informações úteis que podem auxiliar na análise e reduzir o tempo necessário para efetuar os testes.




\section{Conclusão}\label{sec:conclusao}
%O objetivo desse trabalho foi gerar dados para a execução do teste funcional automatizado de aplicações BPM. Foi possível obter uma tabela com todos fluxos possíveis dentro do processo. A criação da tabela possibilita a criação de testes mais completos e com boa cobertura o que, por consequência, contribui para a melhoria da qualidade das aplicações. A tabela gerada também permite que sejam feitas análises importantes sobre o processo como, por exemplo, identificar gargalos.

Esse trabalho buscou contribuir para abreviar o esforço de criação de testes funcionais automatizado de aplicações de BPM. Foi possível obter uma tabela com todos fluxos possíveis dentro de um dado processo. A criação da tabela possibilita a criação de testes mais completos e com boa cobertura. A tabela gerada também permite que sejam feitas análises importantes sobre o processo como, por exemplo, identificar gargalos.

Além da obtenção da própria tabela, a abordagem permite que as informações sejam usadas como entrada na criação de outros elementos. As informações podem ser reutilizadas das mais diversas formas, dependendo de qual estratégia/ferramenta de teste se deseja utilizar. Nesse trabalho decidiu-se por abordar o teste funcional com as ferramentas Selenium e Cucumber. Em um trabalho anterior, a execução do teste funcional automatizado em aplicações BPM com as ferramentas mencionados se mostrou promissora, mas trabalhosa. A abordagem proposta auxilia nesse ponto, permitindo que se utilizem as informações obtidas para gerar códigos necessários para a execução dos testes, auxiliando na automação destes.

A criação automatizada da tabela e dos dois arquivos auxilia a criação dos testes para os sistemas BPM, diminuindo o tempo de análise necessário para a criação dos elementos para o teste dos processos bem como tornando o teste mais completo, pois verifica todos os fluxos que um processo pode seguir. Assim, a qualidade e a cobertura dos testes também pode ser melhorada pois todos os fluxos e cenários possíveis são analisados. Por consequência, a qualidade dos sistemas também pode ser beneficiada com um processo de teste mais completo.

Como trabalhos futuros, tem-se a melhoria de alguns aspectos técnicos da abordagem como melhorar, por exemplo, o tratamento a processos com recursão e reconhecimento dos diferentes nomes de \emph{tags}. Também podem ser avaliadas outras formas de utilizar as informações extraídas dos modelos BPMN, de forma a gerar outros elementos.
%\begin{itemize}
%\item Trabalhos futuros (tirar repeticoes de cenários, tentar gerar mais coisas/informações, verificar outras opções pra utilizar), criar um "dicionário" com o maior numero possível de nomes distintos para cada tag e automatizar esse interpretação
%\end{itemize}
 

%\section{Referências}

\bibliographystyle{sbc}
\bibliography{sbc-template}

\end{document}

%gerando 
